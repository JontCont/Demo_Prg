<!DOCTYPE html>
<html lang="zh-tw">
<head>
    <meta charset="Big-5">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>JontCont-Blog</title>
    <link rel="icon" href="Dlogo.ico" type="image/x-icon"/>    
    <link rel="stylesheet" href="css/page2.css"/>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><!--icon -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><!--jquery  -->
    <!--Bootstrap 4 -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
    <!--done-->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>


</head>
<body style="background-color: rgb(218, 218, 218);">
<!-- header -->
<div class="jumbotron" style="margin-bottom:0">
  <h1 >welcome JontCont - Blog</h1><hr/>
  <p>The homemade blog programming</p>
</div>
<!--nav active design-->
    <nav class="navbar navbar-expand-lg bg-dark navbar-dark">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
            <span class="navbar-toggler-icon"></span>
        </button>    
        <!--ex :<img src="Hlogo.ico" width="30" height="30" class="d-inline-block align-top" alt="">-->      
        <a class="navbar-brand mx-auto" href="..\home.html">JCont</a>
        <div class="collapse navbar-collapse" id="collapsibleNavbar">
            <ul class="navbar-nav mr-auto"><!--mr-auto-->
                <li class="nav-item">
                    <a class="nav-link" href="..\directory.html">directory</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="..\about.html">about</a>
                </li>   
            </ul>
            <br>     
      </div>
    </nav>
    
<div class="container" >
  <div class="row justify-content-center" style="padding-top: 20px;" >
    <h2>[GIT] Useing Git Command line : Day 2</h2>
  </div><hr/>
</div>

<!--container-->
<div class="container" style="margin-top:30px;">
    <div class="row font-seting" >
        <div class="col-lg-12 ">
		<img src="../images/cmdVSgit.png" alt="" style="width: 60%;"/><br/><br/>
		<p><span style="font-size: 36px;"><strong>&nbsp;所有<span style="font-family: 'Times New Roman';">GIT</span> 相關指令:</strong></span></p>


<table border="2">
	<tbody>
	<tr>
	<td>
	<p style="text-align: center;"><span style="font-size:40px;;">基本操作 :</span></p>
	<p style="padding-left: 30px; text-align: center;">HEAD&nbsp;是一個象徵性的指標，通常會指向某個(支點) branch 最近一次 commit 的內容。</p>
	<ol style="font-size:20px;">
		<li><code class="highlighter-rouge ">$	git init</code><br />=&gt;初始化git環境。<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git status</code><br />=&gt;顯示目前的檔案修改情況<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git status -s</code><br />=&gt; 簡短的方式顯示 git status<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log</code><br />=&gt; 顯示目前已經 commit 的所有修改內容，後續可以增加參數來進行過濾<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log --no-merges</code><br />=&gt; 顯示目前已經 commit 的所有修改內容，並剔除 merge 時所產生的額外訊息<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log --decorate</code><br />=&gt; 除了顯示目前已經 commit 的所有修改內容之外，還顯示相關的 branch<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log --name-status</code><br />=&gt; 顯示目前已經 commit 的修改內容的檔案名稱<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log --oneline</code><br />=&gt;以第一行顯示目前已經 commit 的修改內容<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log origin/master..HEAD</code><br />&nbsp;=&gt; 顯示 HEAD 對於 origin/master 所新增的 commit 內容；此指令相等於 git log ^origin/master HEAD，也相等於 git log HEAD --not origin/master，指的是顯示只在 HEAD 中出現，而 origin/master 沒有的 commit 內容。<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log HEAD..origin/master</code><br />=&gt;顯示 origin/master 對於 HEAD 所新增的 commit 內容<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log HEAD...origin/master</code><br />=&gt;顯示 origin/master 與 HEAD 所有相異的 commit 內容<br /><br /></li>
		<li><code class="highlighter-rouge ">$	git log HEAD...origin/master --left-right</code><br />=&gt; 顯示 origin/master 與 HEAD 所有相異的 commit 內容，並加上方向性，指出那個 commit 是 HEAD 所有，還是 origin/master 所有git show :</li>
	</ol>
	<p style="padding-left: 60px; font-size:20px;">
		<code class="highlighter-rouge ">$git show& </code><br />=&gt; 顯示目前 branch 最新 commit 的修改內容<br /><br />
		<code class="highlighter-rouge ">$git show HEAD^</code><br />=&gt;顯示 HEAD 的前一個 commit 的修改內容<br /><br /> 
		<code class="highlighter-rouge ">git show HEAD~3^2</code><br />=&gt; 顯示 HEAD 的前三個 commit 中第二個 parent 的修改內容<br /> <br /> 
		<code class="highlighter-rouge ">git show {commit_hash}</code><br />=&gt;顯示該 {commit_hash} 的修改內容<br /><br />
	</p>
		
		<table>
			<tbody style="font-size:20px;">
			<tr >
			<td style="width: 511px; text-align: right;">設定檔: .gitignore</td>
			<td style="width: 511px; text-align: left;">=&gt; 設定讓 git 忽視的檔案</td>
			</tr>
			<tr>
			<td style="width: 511px; text-align: right;">設定檔: .git/info/exclude</td>
			<td style="width: 511px; text-align: left;">=&gt; 也是設定讓 git 忽視的檔案</td>
			</tr>
			</tbody>
		</table>
	
	</td>
	</tr>
	</tbody>
</table>



<table border="2" style="width:100%;">
	<tbody>
		<tr >
			<td >
			<p style="text-align: center;font-size:40px;">檔案管理</p><br/>
			<ol style="font-size:20px;">
				<li><code class="highlighter-rouge ">$	git diff </code><br />=&gt;顯示目前在 working directory 的修改內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git diff --staged </code><br />=&gt;顯示目前在 staging area 的修改內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git diff --cached</code><br />=&gt; 效果同 git diff --staged<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git diff HEAD </code><br />=&gt; 效果同 git diff + git diff --staged，也就是顯示目前在 working directory 及 staging area 的修改內容<br /><br /> </li>
				<li><code class="highlighter-rouge ">$	git diff Remote_Branch </code><br />=&gt; 查看目前在 working directory 與遠端主機的 Remote_Branch 的修改內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git diff --check</code><br />=&gt;檢查修改內容的行尾是否有多餘的空白字元<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git add {file_name}</code><br />=&gt; 將修改的內容送到 staging area<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git add -i {file_name}</code><br />=&gt;以 interactive 的方式作 git add，相同於&nbsp;git add --interactive<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git add -p {file_name}</code><br />=&gt; 將修改的內容分成多次送到 git add，相同於&nbsp;git add --patch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git add -A</code><br />=&gt;將所有的修改內容送到 staging area，包含新增加的檔案<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git add -u</code><br />=&gt;只將 git 目前有追縱的檔案的修改內容送到 staging area<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git add -f {file_name}</code><br />=&gt;強制將 git ignore 的檔案的修改內容送到 staging area<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rm --cached {file_name}</code><br />=&gt; 在 staged area 移除該檔案，但保留該檔案至 working directory<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git mv {file_name} {new_file_name}</code><br />=&gt;將檔案重新命名、移動位置<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git reset HEAD {file_name}</code><br />=&gt; 將該檔案的修改從 staging area 移到 working directory<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git reset -p {file_name}</code><br />=&gt; 將修改的內容分成多次作 git reset，相同於&nbsp;git reset --patch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git reset reference~#</code><br />=&gt;將 branch 的 commit 往回移動到 reference~#，但在 working directory 保留這些修改<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git reset --soft reference~#</code><br />=&gt;將 branch 的 commit 往回移動到 reference~#，但在 staging area 保留這些修改<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git reset --hard reference~#</code><br />=&gt;將 branch 的 commit 往回移動到 reference~#，且不保留這些修改<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git clean (-n) -f (-x)</code><br />=&gt; 移除未追縱也未忽略的檔案，加上 -n 選項為模擬移除，加上 -x 選項為連忽略的檔案也一併移除<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git clean (-n) -f -d (-x)</code><br />=&gt; 移除未追縱也未忽略的檔案及資料夾，加上 -n 選項為模擬移除，加上 -x 選項為連忽略的檔案也一併移除<br /><br /></li>
			</ol>
			</td>
		</tr>
	</tbody>
</table>

<table border="2">
	<tbody>
		<tr>
			<td>
			<p style="text-align: center;"><span style="font-size: 40px;">commit 管理</span><br /> </p>
			<ol style="font-size:20px;">
				<li><code class="highlighter-rouge ">$	git commit </code><br />=&gt; 提交 staging area 所修改的內容至 local repo<br /><br /> </li>
				<li><code class="highlighter-rouge ">$	git commit -m "message"</code><<br />=&gt;提交 staging area 所修改的內容至 local repo，並設定 commit message<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git commit -a</code><br />=&gt;提交所有的修改內容至 local repo，包含在 working directory 及 staging area 所作的修改<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git commit --amend</code><br />=&gt;將目前 staging area 的修改內容與上一次的 commit 內容合併，如果 staging area 的沒有修改內容，則為單純修改上一次的 commit 內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git log --pretty=raw</code><br />=&gt; 顯示目前已經 commit 的所有修改內容，並增加 tree, parent ... 的欄位<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git reflog</code><br />=&gt;顯示所有有關 HEAD 的改變紀錄<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git log -g</code><br />=&gt;顯示目前已經 commit 的所有修改內容，並增加 reflog 的欄位<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git cherry-pick {commit_hash}</code><br />=&gt;將該{commit_hash} 的內容複製到目前 branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rebase {branch_name}</code><br/>=&gt;以 {branch_name} 為 base，將目前 branch 的 commit 內容轉接過去<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rebase {branch_name} Target_Branch</code><br />=&gt; 在本機端，以 {branch_name} 為 base，將 Target_Branch 的 commit 內容轉接到 {branch_name}<br /> 相同於&nbsp;git checkout Target_Branch; git rebase {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rebase --onto {branch_name_1} {branch_name_2} Target_Branch</code><br />=&gt; 本機端中，以 {branch_name_1} 為 base，將 Target_Branch 在以 {branch_name_2} 為基礎，所新增的 commit 內容，轉接到 {branch_name_1}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rebase --skip</code><br />=&gt; 作 git rebase 時，如果發生 conflict，選擇放棄 {branch_name_2} 的 patch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rebase --abort</code><br />=&gt; 作 git rebase 時，如果發生 conflict，選擇回到原本的 branch 並放棄此 rebase 及其修改<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git rebase -i reference~#</code><br />=&gt; 本機端中，透過編輯器 (vi) 重新挑選、排列、修改、分離、結合&hellip;，在 reference~# 之後的所有 commit 內容</li>
			</ol>
			</td>
		</tr>
	</tbody>
</table>

<table border="2">
	<tbody>
		<tr>
		<td>
		<p style="text-align: center; font-size:40px;">branch 管理<br /><br /></p>
			<ol style="font-size:20px;">
				<li><code class="highlighter-rouge ">$	git branch (-a) (-v(v))</code><br />=&gt; 顯示所有 branch， (包含遠端) (包含 last commit 訊息 (顯示 tracked branch))<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git branch {branch_name}</code><br />=&gt; 在本機端，建立一個指向目前 commit 的程式內容的 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git branch -f {branch_name} reference~#</code><br />=&gt; 在本機端，將 {branch_name} 移動到 reference~#<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git branch -d {branch_name}</code><br />=&gt; 在本機端，刪除 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git checkout -- {file_name}</code><br />=&gt; 在本機端，移除將該檔案在 working directory 的修改<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git checkout -p {file_name}</code><br />=&gt; 在本機端， 將修改的內容分成多次作 git checkout，相同於&nbsp;git checkout --patch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git checkout {branch_name}</code><br />=&gt; 在本機端，切換目前的 branch 到 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git checkout -b {branch_name}</code><br />=&gt; 在本機端，建立一個指向目前 commit 的程式內容的 {branch_name}，並切換目前的 branch 到 {branch_name}，相同於：git branch {branch_name}; git checkout {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git checkout {commit_hash}</code><br />=&gt; 在本機端，將 HEAD 指向 {commit_hash} 的內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git merge {branch_name}</code><br />=&gt; 在本機端，將 {branch_name} 的 commit 內容，結合到目前的 branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git format-patch reference~#</code><br />=&gt; 在本機端，產生目前位置與 reference~# 之間，每個 commit 之間的 patch 檔<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git apply {patch_file_name}</code><br />=&gt; 在本機端，利用 patch 檔來修改檔案<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git am {patch_file_name}</code><br />=&gt; 利用 patch 檔來修改檔案，並自動 commit。除了利用 {commit_hash} 之外，也可以利用相對於 reference 的符號來表示，reference 可以是 {branch_name} ，也可以是 HEAD 本身：<br /><br />
					<code class="highlighter-rouge ">$	git checkout reference^</code><br />=&gt; 將 HEAD 指向該 reference 的 parent<br /><br />
					<code class="highlighter-rouge ">$	git checkout reference~#</code><br />=&gt; 將 HEAD 指向該 reference 的前 # 個 parent<br /><br />
					<code class="highlighter-rouge ">$	git revert reference~#</code><br />=&gt; 新增一個 commit，對 reference~# 的內容作回復</li>
			</ol>
		</td>
		</tr>
	</tbody>
</table>


<table border="2">
	<tbody>
		<tr>
		<td>
		<p style="text-align: center;font-size:40px;">遠端主機<br /> </p>
			<ol style="font-size:20px;">
				<li><code class="highlighter-rouge ">$	git clone &lt;repo URL</code><br />=&gt; 在本機端，將遠端檔案庫的全部檔案複製一份下來<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git clone &lt;repo URL&gt; -b &lt;branch name</code><br />=&gt; 在本機端，將遠端檔案庫的全部檔案複製一份下來，並指定 branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git clone &lt;repo URL&gt; &lt;folder name/path</code><br />=&gt; 在本機端，將遠端檔案庫的全部檔案複製一份下來，並指定下載路徑<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git clone &lt;local project</code><br />=&gt; 在本機端，將本機端的檔案庫作備份<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git remote</code><br />=&gt; 在本機端，顯示遠端檔案庫的名稱<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git remote show Remote_Repository</code><br />=&gt; 在本機端，顯示遠端檔案庫的詳細資訊<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git remote -v</code><br />=&gt; 在本機端，顯示 fetch, push 遠端檔案庫的資訊<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git fetch</code><br />=&gt; 將本機端所有的 origin/branch 更新與遠端主機的同名 remote branch 相同在 git fetch 完之後，要和本機端的已經修改過程式碼作結合，可以有好幾種作法，例如：<br /> git cherry-pick origin/master<br /> git rebase origin/master<br /> git merge origin/master<br /> </li>
				<li><code class="highlighter-rouge ">$	git pull</code><br />=&gt; 在本機端，結合 git fetch 與 git merge origin/master 的效果<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git pull --rebase</code><br />=&gt; 在本機端，結合 git fetch 與 git rebase origin/master 的效果<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git fetch origin Remote_Branch</code><br />=&gt; 將本機端的同名 origin/branch 更新到與遠端主機的 Remote_Branch 相同<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git fetch origin Remote_Branch:New_Local_Branch</code><br />=&gt; 在本機端新增 New_Local_Branch，並將 New_Local_Branch 更新到與遠端主機的 Remote_Branch 相同<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git fetch origin :{branch_name}</code><br />=&gt; 在本機端，建立一個指向 origin/master 最近 commit 程式內容的 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git push</code><br />=&gt; 將本機端目前所在的 branch 所作的修改上傳到遠端主機的同名 branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git push origin Local_Branch</code><br />=&gt; 將本機端 Local_Branch 所作的修改上傳到遠端主機的同名 branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git push origin Local_Branch:Remote_Branch</code><br />=&gt; 將本機端 Local_Branch 所作的修改上傳到遠端主機的 Remote_Branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git push origin Local_Branch:New_Remote_Branch</code><br />=&gt; 在遠端主機新增 New_Remote_Branch，並將本機端 Local_Branch 所作的修改上傳到新增的遠端主機的New_Remote_Branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git push origin :{branch_name}</code><br />=&gt; 刪除遠端主機的 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git push origin --delete {branch_name}</code><br />=&gt; 刪除遠端主機的 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git branch {branch_name} origin/master</code><br />=&gt; 在本機端，建立一個追縱 origin/master 的 {branch_name}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git branch -u origin/master {branch_name}</code><br />=&gt; 在本機端，將 {branch_name} 設定為追縱 origin/master<br /> <br /> 
					<code class="highlighter-rouge ">$	git branch -u origin/master</code><br />=&gt; 在本機端，將目前的 branch 設定為追縱 origin/master而 -u 也可以換成 --set-upstream-to<br /> <br /> 
					<code class="highlighter-rouge ">$	git branch --unset-upstream</code><br />=&gt; 在本機端，將目前的 branch 取消追蹤遠端分支<br /> <br /> 
					<code class="highlighter-rouge ">$	git branch --unset-upstream {branch_name}</code><br />=&gt; 在本機端，將 {branch_name} 取消追蹤遠端分支<br /> <br /> 
					<code class="highlighter-rouge ">$	git checkout -b {branch_name} origin/master</code><br />=&gt; 在本機端，建立一個追縱 origin/master 的 {branch_name}，並切換目前的 branch 到 {branch_name}，相同於：git branch {branch_name} origin/master; git checkout {branch_name}<br /> </li>
			</ol>
		</td>
		</tr>
	</tbody>
</table>


<table border="2">
	<tbody>
		<tr>
		<td>
		<p style="text-align: center;font-size:40px;">其它<br /></p>
			<ol style="font-size:20px;">
				<li><code class="highlighter-rouge ">$	git stash</code><br />=&gt; 將還沒 commit 的修改部分，暫時儲存並移除，回復到最近 commit 的內容，相同於&nbsp;git stash save<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash --keep-index</code><br />=&gt; 將還沒移到 stage 的修改部分，暫時儲存並移除<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash --patch</code><br />=&gt;以 patch 的方式作 git stash<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash -u</code><br />=&gt;將還沒 commit 的修改部分以及未追縱的檔案，暫時儲存並移除，回復到最近 commit 的內容，相同於&nbsp;git stash save -u<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash save "message"</code><br />=&gt;將還沒 commit 的修改部分，暫時儲存並移除，回復到最近 commit 的內容，並加上 message 描述此次的 stash 內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash show</code><br />=&gt;查看由 git stash 所儲存的修改檔案名稱<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash list</code><br />=&gt;查看由 git stash 所儲存的修改列表<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash pop</code><br />=&gt;回復由 git stash@{0} 所儲存的修改部分，並刪除 stash@{0}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash branch {new_branch_name}</code><br />=&gt;新建立一個 branch，並在該 branch 作 git stash pop<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash apply</code><br />=&gt;回復由 git stash@{0} 所儲存的修改部分，但不刪除 stash@{0}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git stash apply --index</code><br />=&gt;回復由 git stash 所儲存的修改部分，但不刪除 stash@{0} ，且分類為 staged 及 not staged<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git tag {commit_hash}</code><br />=&gt;為該 {commit_hash} 加上指向它的 tag<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git describe reference</code><br />=&gt; 在本機端，顯示該 reference 相對於最近 tag 的資訊<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git grep (-n) {keyword}</code><br />=&gt; 在 working directory 顯示包含 {keyword} 的行，-n 為顯示行號，等同於 git grep (--line-number) {keyword}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git grep -c {keyword}</code><br />=&gt; 在 working directory 以檔案為單位計算 {keyword} 出現的次數，等同於 git grep --count {keyword}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git grep -p {keyword}</code><br />=&gt; 在 working directory 顯示包含 {keyword} 的行及其函式名稱，等同於 git grep --show-function {keyword}<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git grep -e {keyword_1} -e {keyword_2}</code><br />=&gt; 在 working directory 顯示包含 {keyword_2} 或 {keyword_2} 的行<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git grep (--heading) (--break) -e {keyword_1} --and -e {keyword_2}</code><br />=&gt; 在 working directory 顯示包含 {keyword_1} 及 {keyword_2} 的行，--heading 為顯示檔案名稱，--break 為檔案與檔案之間隔開一行<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git log -S {keyword}</code><br />=&gt;在 git log 中，顯示{keyword} 出現的次數有變化的 commit<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git log -G {keyword}</code><br />=&gt; 在 git log 中，顯示 {keyword} 那行有修改的 commit<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git log -L :{funcation_name}:{file_name}</code><br />=&gt; 在 git log 中，顯示 {funcation_name} 在 {file_name} 的內容<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git blame {file_name}</code><br />=&gt; 顯示 {file_name} 中每一行最近一次修改的 commit hash、作者、時間<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git remote prune origin (--dry-run)</code><br />=&gt; 清除儲存在本機端但遠端已被刪除的遠端 branch，--dry-run 為模擬，只列出會被刪除的 branch<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git filter-branch --tree-filter 'rm -f passwords.txt' HEAD</code><br />=&gt; 在該 branch 的所有 commit 中，移除檔案 - passwords.txt<br /><br /></li>
				<li><code class="highlighter-rouge ">$	git filter-branch --subdirectory-filter trunk HEAD</code><br />=&gt; 將資料夾 -trunk 的內容，作為目前 branch 的資料內容，並作相關修改<br /> </li>
			</ol>
		</td>
		</tr>
	</tbody>
</table>
<br/><br/>
    <!--<pre><code class="html hljs"></code></per>--->
        
            </div>
    </div>
</div>

<footer id="sticky-footer" class="py-4 bg-dark text-white-50">
    <div  class="container text-center">
      <a href="https://github.com/JontCont" style="color: white;">@jontcont.serveirc.com</a>
    </div>
</footer>
</body>

<script>hljs.initHighlightingOnLoad();</script>
</html>